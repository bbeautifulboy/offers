

#### （一）TCP/IP四层模型 OSI七层模型

TCP/IP四层模型：数据链路层（以太网协议），网络层（ip协议），传输层（tcp协议），应用层（http协议）

OSI七层模型：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层

![image-20210207010006752](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20210207010006752.png)

> 自底向上网络分层

* 物理层：物理层就是通过网线，海底电缆等将各个电脑连接起来，形成一个网络，它负责传输0和1的电路信号。

* 数据链路层：定义协议对0和1电信号进行分组和描述从哪来到哪去。

  以太网协议：一组电信号是一个数据包，叫一个帧（frame）；每个帧分标头（head）和数据（data），标头包含一些说明性的东西如发送者接受者和数据类型之类的，数据就是0和1的电信号。

  以太网协议规定了接入网络里的所有设备都得有网卡，数据链路层传输的以太网协议数据包必须从一个电脑的网卡传输到另一台电脑的网卡，而这个网卡地址就叫mac地址。

  

  所以在以太网传输数据包的时候，必须指定接受者的mac地址才能传输数据。

  但是以太网的数据包是怎么从一个mac地址发送到另一个mac地址？如果在局域网内，一个电脑发送数据包出去，会广播给局域网内的所有电脑设备的网卡；然后每台电脑从数据包里获取接受者的mac地址，跟自己的mac比较，如果一样就说明是发给自己的数据包。

* 网络层：上面说到子网内的电脑通过以太网发送数据包对局域网的电脑广播出去。但是怎么知道哪些电脑在一个子网呢，这就靠网络层的ip协议。通过ip地址就可以区分哪些电脑是一个子网的。

  网络层的ip协议定义的地址叫ip地址，通常是32个二进制数字组成，一般用4个十进制数字表示，范围从0.0.0.0到255.255.255.255之间。

  每台计算机都会分配一个ip地址，对于B类网络前24位代表网络，后8位二进制代表主机。比如192.168.0.1,192.168.0.56和192.168.0.88，前24位都相同，所以代表的是同一个子网，最后的数字代表主机编号。

  但单从ip地址看不出哪些机器是一个子网的，因为从10进制判断不出来，所以需要通过子网掩码来判断，ip地址的二进制跟子网掩码的二进制相与，与运算的结果就代表网络的那部分。如果结果相同则代表两台电脑正在同一子网。

  

  有了网络层ip地址后，两台在子网的电脑就可以通过广播+mac地址对传输的数据包进行通信了。但如果两台计算机不在同一子网内，就不能通过广播来发送数据包，需要提供路由器来发送数据包。

  路由器负责将多个子网进行连接，比如你在自己家就在自己的一个子网，你要是访问网站就跟网站机器所在的子网进行通信。

  每个电脑都可以搞多个网卡，比如笔记本一般都有以太网网卡和wifi网卡，发送数据包的时候决定要走哪个网卡。路由器其实就是配置了多个网卡的一个专用设备，可以通过不同的网卡接入不同的网络。

  

  网关其实也是路由器的一种，运行在网络层。可以把路由器上的ip地址认为是网关，路由器上的每个网卡都有mac地址和对应的ip地址。路由器虽然有mac地址，但是不能通过mac地址寻址，必须通过ip地址寻址，所以路由器是工作在网络层的设备。

  

  网络交换机是工作在数据链路层的设备，它通过mac地址寻址和传输数据包；而路由器是通过ip地址寻址和传输数据包的。网络交换机主要用在局域网的通信，一般架设一个局域网，里面的电脑通信是通过数据链路层发送数据包；通过mac地址来广播的，广播的时候就是用网络交换机这个设备把数据广播到局域网内的其他机器上去。路由器一般用来让你连入因特网的。

  

  LAN，局域网；WAN,广域网；WLAN，无线局域网，就是wifi，在局域网内直接通过wifi无线联网。

  

  家里的路由器就是包含了交换机和路由两个功能的，如果连接到局域网内的设备就把线插LAN；如果连接到因特网就把线插WAN。

  

  举个例子，两个局域网之间通过路由器是怎么通信的。

  大概过程就是，路由器配置了两块网卡，每个网卡可以连接到一个局域网内。

​		局域网1内的电脑要发送数据包到局域网2内的电脑，在数据包写上自己的ip地址和对方的ip地址。但   是他们不再同一个局域网内，于是局域网1的电脑；先通过交换机将数据包发送给路由器，这个过程需要将路由器的一块网卡ip地址和对应的mac地址写到数据包头部，然后通过交换机才能广播出去，路由器接受到之后与自己的一块网卡mac地址比较，就知道是找自己的。

​		接着路由器接收到数据包后，就会在局域网2内，将目标机器的ip地址和对应的mac地址写入头部，接着再次通过交换机发送广播通知，发送给局域网2内的电脑。

​		一个局域网内的每台机器都有自己的ARP cache，这个ARP就是用来在一个局域网内让各个设备都知道每个设备的ip地址和mac地址的对应关系的；一般就是某个机器发送广播通知自己的ip地址和mac地址的对应关系。然后每个机器给他一个回应。以此类推，大家互相这样广播一把就互相都知道对方的ip地址和mac地址对应关系了。

​		一个ip地址对应一个mac地址。

​		所以可以在上面看到，一个子网内的机器之间通信，就是在数据包里写上对方的mac地址，然后通过交换机广播出去就ok了；但是如果是跨子网的通信，就在数据包写上对方的ip地址，然后先通过mac地址广播到路由器，让路由器再根据另外一个子网的ip地址转换位mac地址，通过另外一个子网的交换机广播出去。

![image-20210207174153232](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20210207174153232.png)

* 传输层：

  上面我们大概了解了网络层ip地址怎么划分出来一个个子网，然后子网内部怎么通过mac地址广播通信；跨子网的时候怎么通过ip地址->mac地址->交换机->路由器->ip地址->mac地址->交换机的方式来通过路由器进行通信。

  但是这里有一个问题，就是一台机器上有很多个程序用一个网卡进行网络通信，比如浏览器，qq，视频直播，这些软件都用一个网卡往外面发送数据，然后从网卡接收数据。那怎么确定这个数据包是哪个程序的呢？

  所以这个时候就需要一个端口的概念，就是发送数据包到某个网卡的某个端口去，然后那个机器上监听那个端口的程序，就可以提取发送到这个端口的数据，就知道是自己的数据。端口号是0-65536的范围，0-1023被系统占用了，别的应用程序就用1024以上的端口就可以了。

  电脑1，是在端口48362监听的，通过网卡发送了一条数据->电脑2的ip地址的20386端口->电脑2的上面某个QQ，监听着20386的端口-> 电脑2的网卡接收到一条数据之后，发现人家找的是20386这个端口，就去找谁在监听20386端口，QQ在监听，就把这个网卡传输过来的数据，传递给QQ，通过端口知道，哪条数据是给你的。

  网络层是基于ip协议进行主机和主机之间的寻址和通信的；而传输层就是通过建立某个主机的某个端口，到另外一个主机的某个端口的连接进行通信的。这个通信就是通过socket来实现的，通过socket就可以基于tcp/ip协议完成上面一系列的比如基于ip地址和mac地址转换和寻址，通过过路由器通信之类的，而且会建立一个端口到另一个端口的连接。

  udp和tcp都是传输层的协议，作用就是在数据包加入端口号，可以通过端口号进行点对点的通信。udp是不可靠的，发出去人家收到没有就不知道；tcp是可靠的，要求三次握手，而且要求对方收到数据必须回复你。

  传输层的tcp协议，仅仅只是规定了一套基于端口的点对点的通信协议，包括如何建立连接，如何发送和读取信息，但实际上如果要基于tcp协议开发，一般是用socket，java socket编程。

* 应用层：通过传输层的tcp协议可以传输数据，但是人家收到数据后怎么处理？比如收到个邮件怎么处理？收到个网页怎么处理？所以针对各种不同的应用，邮件，网页之类的，都是定义不同的应用层协议。这个应用层，我们就假设综合了会话层，表示层和应用层，3层合成1层。

  比如最常见的，应用层的协议就是http协议，进行网络通信。

  我们的网络设置里，一般包含了ip地址，子网掩码，网关地址，DNS地址。ip地址和子网掩码用来划分子网，判断哪些ip地址在一个子网内。同时ip地址和mac地址关联起来，唯一定位了网卡。网关地址，就相当于路由器上的那个网卡的ip地址，路由器的网卡也有mac地址，mac地址对应一个ip地址。

  DNS地址是什么？Domain Name System。我们一般定位是通过ip地址+mac地址+端口号定位一个通信目标，但是在浏览器输入了一个www.baidu.com怎么办？这个时候先把网址发送给DNS服务器，然后DNS服务器告诉你网址对应的ip地址。

#### （二）浏览器请求www.baidu.com的全过程是怎样的

TCP/IP四层模型：数据链路层（以太网协议），网络层（ip协议），传输层（tcp协议），应用层（http协议）。

TCP/IP协议我们已经大概了解清楚了，现在我们假设给电脑设置了几个东西：

ip地址：192.168.31.37    子网掩码：255.255.255.0  

网关地址：192.168.31.1   DNS地址：8.8.8.8

我们打开一个浏览器，请求www.baidu.com地址，这个时候找DNS服务器，DNS服务器解析域名之后，返回一个ip地址，比如172.194.26.108.接着判断两个ip地址是不是一个子网的，用子网掩码255.255.255.0，对两个ip地址做与运算，拿到192.168.31.0和172.194.24.0，明显不是一个子网的。

那就会打包一个数据包，层层包裹，然后走交换机；把数据包通过以太网协议广播到网关上；就相当于是我们的路由器，就是192.168.31.1，而且我们是可以拿到网关ip地址的mac地址的，现在我们从应用层出发，通过浏览器访问一个网站，是走应用层的http协议的。

既然要把浏览器发出的请求打包成数据包，要把哪些东西放到数据包中去呢？应该把http请求打包到数据包中去。

http协议分为几个部分：

请求方法+URL地址+http版本：比如GET http://172.194.26.108/test HTTP/1.1,类似这种

请求头，就类似下面这种：

Host:upload.jianshu.io

Proxy-Connection:keep-alive

User-Agent:Mozilla/5.0

空行

请求体，比如常见的可以放一个json

以上这些就构成了一个http请求报文。

浏览器请求一个地址，先按照应用层的http协议，封装一个应用层数据包，数据包里就放了http请求报文。

这个时候会将这个http请求报文打包成一个数据包，仅仅是数据包的数据部分，此时数据包是没有头的。上面根据http协议搞一个http请求报文，然后搞一个数据包出来，就是网络模型中应用层干的事了。

接着就跑到传输层来了，这个层是tcp协议。这个TCP协议会让你设置端口，发送方的端口随机选一个，接收方的端口一般是默认80端口。这个时候，会把应用数据包给封装到TCP数据包中，而且会加一个TCP头。这个TCP数据包是对应一个TCP头的，这个TCP头里放了端口号信息。

接着跑到网络上来了，走ip协议，这个时候会把TCP头和TCP数据包，放到ip数据包里去；然后再搞一个ip头，ip头里放本机和目标机器的ip地址。这里本机地址是192.168.31.37。目标机器是172.194.26.108。

因为通过ip协议，可以判断说，两个ip地址不在一个子网内。所以此时只能将数据包先通过以太网协议广播到网关上去，通过网关再给他发送出去。

接着是数据链路层，这块走的是以太网协议，这里是把ip头和ip数据包封装到以太网数据包里去；然后再加一个以太网数据报的头，头里放了本机Mac地址和网关的Mac地址。但是以太网数据包的限制是1500个字节，但是假设这个时候ip地址包都5000个字节了，那么需要将ip数据包切割一下。

这个时候，一个以太网数据包要切割为四个数据包，每个数据包包含了以太网头，ip头和切割后的ip数据包。四个数据包的大小分别是1500，1500，1500，560。Ip头里包含的每个数据包的序号。

这四个以太网数据包都会通过交换机发到你的网关上，然后你的路由器是可以连通别的子网，这个时候你的路由器就会转发到别的子网，也可能是某个路由器里去；然后以此类推，N多个路由器或者叫网关也行，N多个网关转发后就会跑到百度的某台服务器，接收到四个以太网数据包。

百度服务器接收到四个以太网数据包后，根据ip头的序号，把4个以太网数据包里的ip数据包给拼起来，就还原成一个完整的数据包了。接着就从ip数据包里拿出TCP数据包，再从TCP数据包里取出http数据包，读取出来的HTTP数据包里的各种协议内容；接着就是做一些处理，然后再把响应结果封装成http响应报文，封装在HTTP数据包里，再一样的过程，封装TCP数据包，封装ip数据包，接着通过网关给发回去。

![image-20210207213936081](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20210207213936081.png)

![image-20210207214119124](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20210207214119124.png)

![image-20210207214159780](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20210207214159780.png)

#### （三）TCP三次握手和四次挥手

>  TCP三次握手                  

![image-20210207235959495](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20210207235959495.png)

* 三次握手过程：张三首先向李四招手(**syn**)，李四看到张三向自己招手后，向对方点了点头挤出了一个微笑(**ack**)。张三看到李四微笑后确认了李四成功辨认出了自己(进入**estalished**状态)。

  但是李四还有点狐疑，向四周看了一看，有没有可能张三是在看别人呢，他也需要确认一下。所以李四也向张三招了招手(**syn**)，张三看到李四向自己招手后知道对方是在寻求自己的确认，于是也点了点头挤出了微笑(**ack**)，李四看到对方的微笑后确认了张三就是在向自己打招呼(进入**established**状态)。

![image-20210208000042879](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20210208000042879.png)

* 如果是两次握手：假设两次握手就ok，那如果客户端第一次握手过去，结果卡在某个地方了没到服务端；完了客户端再重新发送第一次握手过去，服务端收到了，ok，此时客户端服务端两次握手建立了连接。

  结果尴尬的是，后来那个卡在那里的老的第一次握手发到了服务端，服务端就直接返回一个第二次握手，这个时候服务器开辟了资源准备客户端发送数据。结果，客户端根本不理会这个发过来的第二次握手，因为之前已经通信过了。这时候服务端就干等着，资源就白白浪费了。

![image-20210208001838516](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20210208001838516.png)

但如果是三次握手，那个第二次握手发过来，客户端发现根本不对，就会发送个复位报文过去，让服务端撤销开辟的资源，别等着了。因为三次握手就够了，所以就不需要4次或5次浪费资源了。

![image-20210208002518003](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20210208002518003.png)



> TCP四次挥手

![image-20210208002955706](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20210208002955706.png)

* 四次挥手过程：TCP断开链接的过程和建立链接的过程比较类似，只不过中间的两部并不总是会合成一步走，所以它分成了4个动作，张三挥手(fin)——李四伤感地微笑(ack)——李四挥手(fin)——张三伤感地微笑(ack)。

![image-20210208002741899](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20210208002741899.png)

* 为什么要等2个MSL：![image-20210208004638416](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20210208004638416.png)

#### （四）HTTP协议的工作原理

http原理：

![image-20210208023139429](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20210208023139429.png)

http1.0：

![image-20210208023539249](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20210208023539249.png)

http1.1：

![image-20210208023606261](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20210208023606261.png)

http2.0：

![image-20210208023727809](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20210208023727809.png)

#### （五）https的工作原理，为什么能加密通信

http和https的区别：

![image-20210208024103572](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20210208024103572.png)

https的工作原理：

![image-20210208024138694](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20210208024138694.png)

![image-20210208025930532](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20210208025930532.png)

![image-20210208025842306](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20210208025842306.png)

http长连接：

![image-20210208030908331](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20210208030908331.png)

#### （六）cookie session

Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。

**Cookie 一般用来保存用户信息** 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。**Session 的主要作用就是通过服务端记录用户的状态。** 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。

Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。

Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。











