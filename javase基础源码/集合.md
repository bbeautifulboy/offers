#### （一）ArrayList和LinkedList

> ArrayList

* ArrayList的底层就是用数组实现的，查询快，删除慢，线程不安全；

* ArrayList默认初始化的时候数据量时0，当add的时候默认会变成10，每次扩容是他之前的1.5倍。

* 他是动态数组，自动扩容；添加元素不够时，新建长度为原数组长度*扩容因子的数组，并将原数组元素赋值给新数组，原数组被gc回收。



> LinkedList

* LinkdeList是双向链表，他有头插法和尾插法，因为不想数组有脚标所以查询的时候需要一个个遍历效率慢。







#### （二）HashMap

![image-20210130135006220](%E9%9B%86%E5%90%88.assets/image-20210130135006220.png)

* put，get方法和哈希碰撞：

  1.算出key的哈希值，到数组中寻址，找到一个位置，把key-value对放进数组或者从里面取出来。

  2.两个或多个key算出来的hash值与n-1，与运算后发现定位数组的位置一样，则hash碰撞。此时会在这个位置挂一个链表，这个链表里面放多个key-value对，同时放在数组的一个位置里。get的话就遍历此链表找到自己要的key-value即可。



* HashMap1.8后链表和红黑树是相互转换的：当链表长度>=8且数组长度>=64时，会将单链表转换成红黑树的形式存储。 红黑树的长度<=6时，会重新再转换成单链表。![image-20210130135600695](%E9%9B%86%E5%90%88.assets/image-20210130135600695.png)



* 扩容：HashMap的数量默认是16个，它的负载因子是0.75。

  1.扩容的时候首先会检测数组里的元素个数，如果个数大于阈值（16*0.75=12），它的容量就会扩容成之前哈希桶的两倍（同乘2的N次幂）。

  2.然后把之前的元素重新进行一次哈希运算添加到新的哈希桶里面，按照链表或红黑树的方式再排列出来。

  

* 线程不安全：1.7之前采用的是头插法，会造成链表闭环，所以1.8之后采用尾插优化了。但还是线程不安全的，可以有vector，collection.sychroinsedList（new ArrayList）和concurrentHashMap替代。



* 1.8后的hash算法的优化和寻址算法的优化：

  1.hash算法优化：对每一个hash值，在他的低16位中，让它的高低16位进行异或，让它的低16位同时保持了高低16位的特征，尽量避免hash值后续的冲突，大家可能会进入数组的同一个位置。

  2.寻址算法的优化：用与运算替代取模，提升性能。

![image-20210130145441253](%E9%9B%86%E5%90%88.assets/image-20210130145441253.png)

* hashCode定位下标，equal定位节点元素



#### （三）ConcurrentHahMap

HashMap在多线程存在不安全隐患。因此可用ConcurrentHashMap来替代了，虽然HashTable也可以但是锁的粒度太粗，直接整个Table锁住了，效率太低，所以一般都用ConcurrentHashMap。![image-20210130170842210](%E9%9B%86%E5%90%88.assets/image-20210130170842210.png)



* 1.7：将数据分为一段一段的存储，给每一段数据配一把锁（Segment），当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。

==ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。==

Segment继承了ReentrantLock，是一种可重入锁，扮演锁的角色。HashEntry用于存储键值对数据。当线程想要对HashEntry数组的数据进行修改时，必须先获得对应的Segment的锁。

![image-20210130171016470](%E9%9B%86%E5%90%88.assets/image-20210130171016470.png)



* 1.8：数组+单链表+红黑树（在链表长度超过8时，将链表转换为红黑树）。

  ==使用CAS+synchronize来操作==：

  1. 重新变回一个大数组，数组里每一个元素进行put操作都有一个不同的锁。两个线程同时对数组[5]put的时候，采取CAS策略；
  2. 同一时间只有一个线程能成功执行CAS操作，就是说他刚开始先获取这个数组[5]的值为null，然后执行CAS，线程1比较一下，put进去我这条数据，同时其他线程就会执行CAS失败。这就相当于1.7的分段加锁了。
  3. 通过对数组每个元素执行CAS策略，如果很多线程对数组里不同元素执行put，大家无关联，可以并发执行。
  4. 但要对同一位置执行put操作，其他线程发现CAS失败了，说明刚才已经有人放值进去了，这时需要在这里基于链表+红黑树进行处理，synchronized(数组[5])，加锁，基于链表或红黑树在这个位置插自己的数据。

  

![image-20210130171230410](%E9%9B%86%E5%90%88.assets/image-20210130171230410.png)































